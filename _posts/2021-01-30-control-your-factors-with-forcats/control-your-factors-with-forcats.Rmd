---
title: "Feel like the cat that got the cream with {forcats}"
description: |
  Do mi do mi do so mi do,
  
  Every truly cultured tidyverse stud-ent knows,
  
  You must learn your forcats and your d-plyr.
  
    -- Adapted from 'Scales and Arpeggios' from the Aristocats
author:
  - name: Vebash Naidoo
    url: https://twitter.com/Sciencificity
date: 2021-01-31
base_url: https://sciencificity-blog.netlify.app/
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
    self_contained: false
    code_folding: false
categories:
  - Categorical Variables
  - Factors
  - forcats
preview: preview.jpg
draft: false
---

<!-- Picture on main page -->
<!-- <span>Photo by <a href="https://unsplash.com/@v2osk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">v2osk</a> on <a href="https://unsplash.com/s/photos/categories?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span> -->



```{r setup, include=FALSE}
library(formatR)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE) #,
                      # R.options =	list(width = 60))
# Set so that long lines in R will be wrapped:
# knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=TRUE)

```


```{css, echo = FALSE, code_folding = FALSE}
blockquote {
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
  quotes: "\201C""\201D""\2018""\2019";
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 4em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}
blockquote p {
  display: inline;
}
```

<figure class="quote">
  <blockquote>
    No need to be a scared-y cat, “A lot of good tricks. I will show them to you. Your mother will not mind at all if I do.”
  </blockquote>
  <figcaption>
    &mdash; The Cat In The Hat  </figcaption>
</figure>

<img src = 1.jpg  width = 600px>

<span>Photo by <a href="https://unsplash.com/@miklevasilyev?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">MIKHAIL VASILYEV</a> on <a href="https://unsplash.com/s/photos/cat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

# Terminology

To set the stage, let's talk about the types of data. These are concepts more for beginners, so if you're familiar with these please feel free to skip ahead.

We have two types of data:

- Numerical data, also known as `Quantitative` data.
- Non-Numerical data, also known as `Qualitative` data (this is what we will be concentrating on in this post).

### Numerical (Quantitative) data

- Takes on number values:

    * Discrete: These are for example, count values: 0, 1, 2 - 
    how many people took the survey, how many cats do you have 
    in your home, how many children (aged below 18) are there in a household?
    
    * Continuous: These are numbers that can take on infinite
    values within some range of values - percentage of survey
    filled by respondents (e.g. 21.562%, 67.893%, 90.145%),
    heights of siberian cats (30.167 cm, 31.458 cm, 28.624 cm).
    
- It makes sense to take the average of numerical data, and to do 
other arithmetic on numerical data, such as to add, subtract etc.

- For example, it's easy to say, in our sample the tallest siberian cat is `r 31.458 - 30.167` centimetres taller than the shortest siberian cat.

### Non-Numerical (Qualitative) data

- Also known as __categorical data__, since it can take on some
number of distinct categories e.g. eye colour (brown, blue, green, grey etc.), favourite rock band, even names if you think about it, fall under categorical data, albeit many distinct categories may be present in such a `name` variable, and we therefore typically treat those kinds of non-numerical fields as pure character data.
- The categories are limited, and distinct - Siberian cat, Cornish Rex, Russian Blue - and may therefore be _represented_ as numbers. In R each distinct category is referred to as a <span style="color: #5196b4;background-color:#f4e4e7">level</span>. 

    *   For example, you may have a survey question with the following categories:

    |      Category|  Level Number| 
    |-------------:|-------------:|
    |   Very Likely|             1| 
    |        Likely|             2| 
    |     Uncertain|             3|
    |      Unlikely|             4|
    | Very Unlikely|             5|
    
    There are 5 levels.



    *   Or, you may have a question asking a participant which of your favourite songs they enjoy the most, with the following categories:

    |                     Category|  Level Number|
    |----------------------------:|-------------:|
    |          Sweet Child O' Mine|             1| 
    |      Smells Like Teen Spirit|             2| 
    |             Hotel California|             3|
    |                  Best of You|             4| 
    |                         Numb|             5| 
    | Unfamiliar with all of these|             6| 
    
    There are 6 levels.

- The numbers (`Level Number`) are basically placeholders for each category level, and is meant for us to work with it easier in a programming language. If I get the responses:<br>

<pre>

      Numb, Smells Like Teen Spirit, Sweet Child O' Mine, Smells Like Teen Spirit, Numb,
      Smells Like Teen Spirit, Sweet Child O' Mine, Numb, Smells Like Teen Spirit, Numb,
      Sweet Child O' Mine, Sweet Child O' Mine, Smells Like Teen Spirit
      
      I.e. 5, 2, 1, 2, 5, 2, 1, 5, 2, 5, 1, 1, 2
      
</pre>

  I can't say <i>Numb</i> is 4x better, or 4x worse than _Sweet Child O' Mine_ (in other words, it makes no sense to take Level Number of Numb [5], and subtract Level Number of Sweet Child 'O Mine [1]). 
  
  Neither can I say that _Hotel California_ is the average category chosen (notice it was not chosen once) but if I take the average of the numerical placeholders for the responses received, I would get `r round(mean(c(5, 2, 1, 2, 5, 2, 1, 5, 2, 5, 1, 1, 2)),2)` which is 3 if I round up. In other words, we can't understand what the "average" song is.

- So we have seen that it does not make sense to do arithmetic on these variables. The distance between the categories is not something that can be measured. 

- We __can__ count each category, and understand that _Smells Like Teen Spirit_ was the most popular among respondents.

- Categorical data may be:

    * Unordered, often refered to merely as Categorical data, or also known as <span style="color: #5196b4;background-color:#f4e4e7">`Nominal`</span> data. For example, if your question is "`What's your favourite Altoids flavour?`" with the following options, while you may rank _Cinnamon_ above _Wintergreen_ there is no order to these categories! `r emo::ji("grin")`.
    
    |      Fave Flavour|  Level Number| 
    |-----------------:|-------------:|
    |        Peppermint|             1| 
    |       Wintergreen|             2| 
    |          Cinnamon|             3|
    |         Spearmint|             4|
    |         Liqourice|             5|
    |     None of these|             6|
    
    
    * Ordered, and hence called <span style="color: #5196b4;background-color:#f4e4e7">`Ordinal`</span> data. Here's an example using age categories - these are not numerical data, because the `Level Number` is merely a placeholder for the category, and we can't do arithmetic on these. This is an `Ordinal` variable however, since there is some order to the distinct categories shown in `Age Range`.
    
    |      Age Range|  Level Number| 
    |--------------:|-------------:|
    |Younger than 21|             1| 
    |          21-30|             2| 
    |          31-45|             3|
    |          46-55|             4|
    |  Older than 55|             5|
    

# {forcats} `r emo::ji("package")`

The <span style="color: #5196b4;background-color:#f4e4e7">forcats</span>  `r emo::ji("package")` is meant to handle `factors` which is R's data type for categorical data. `forcats` is __for__ <b>cat</b>egorical data, and is an [anagram](https://r4ds.had.co.nz/factors.html) for `factors` `r emo::ji("cool")`. 

The functions in the package start with <span style="color: #5196b4;background-color:#f4e4e7">`fct_`</span>.

There is non-numeric data where it is useful to work with the data as factors (age-ranges, occupation, etc.), but we must also keep in mind that some non-numeric data should be kept as `character` data.

We're going to work with non-numeric data that may be treated as factors in this post, and learn how to use the forcats `r emo::ji("package")` to make that task easier for us.

## Data

We're going to use the data from the awesome [TidyTuesday Project](https://github.com/rfordatascience/tidytuesday) `r emo::ji("sparkle")`:

- [Beer production data from 2020-03-31](https://github.com/rfordatascience/tidytuesday/tree/master/data/2020/2020-03-31)
- [Beer awards data from 2020-10-20](https://github.com/rfordatascience/tidytuesday/tree/master/data/2020/2020-10-20).

```{r, cache = TRUE}
library(tidyverse)
brewing_materials <-
   read_csv(
    # hacky solution to show readers the full path of file
    # str_glue just pastes the various strings next to each other
    str_glue('https://raw.githubusercontent.com/rfordatascience/',
            'tidytuesday/master/data/2020/2020-03-31/',
            'brewing_materials.csv'))
beer_taxed <- 
    read_csv(
     str_glue('https://raw.githubusercontent.com/rfordatascience/', 
              'tidytuesday/master/data/2020/2020-03-31/',
              'beer_taxed.csv'))

brewer_size <- 
    read_csv(
     str_glue('https://raw.githubusercontent.com/rfordatascience/',
     'tidytuesday/master/data/2020/2020-03-31/',
     'brewer_size.csv'))

beer_states <- 
    read_csv(
     str_glue('https://raw.githubusercontent.com/rfordatascience/', 
     'tidytuesday/master/data/2020/2020-03-31/',
     'beer_states.csv'))

beer_awards <- 
    read_csv(
     str_glue('https://raw.githubusercontent.com/rfordatascience/', 
     'tidytuesday/master/data/2020/2020-10-20/',
     'beer_awards.csv'))
```

Let's have a look at the data - here we're showing a sample from each table.

```{r, code_folding = TRUE}
brewing_materials %>% 
  sample_n(50) %>% 
  DT::datatable(filter = 'top', list(scrollX = TRUE,
                     pageLength = 5),
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
     'Table Name: ', htmltools::em('Brewing Materials')
  ))

beer_taxed %>% 
  head(50) %>% 
  DT::datatable(filter = 'top', list(scrollX = TRUE,
                     pageLength = 5),    
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
     'Table Name: ', htmltools::em('Beer Taxed')
  ))

brewer_size %>% 
  sample_n(50) %>% 
  DT::datatable(filter = 'top', list(scrollX = TRUE,
                     pageLength = 5),
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
     'Table Name: ', htmltools::em('Brewer Size')
  ))


beer_states %>% 
  sample_n(50) %>% 
  DT::datatable(filter = 'top', list(scrollX = TRUE,
                     pageLength = 5),
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
     'Table Name: ', htmltools::em('Beer States')
  ))

beer_awards %>% 
  sample_n(50) %>% 
  DT::datatable(filter = 'top', list(scrollX = TRUE,
                     pageLength = 5),
    caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
     'Table Name: ', htmltools::em('Beer Awards')
  ))
```


## Convert variable to factor

To convert a variable to a factor we use <span style="color: #5196b4;background-color:#f4e4e7">`factor()`</span> / <span style="color: #5196b4;background-color:#f4e4e7">`as.factor()`</span> or <span style="color: #5196b4;background-color:#f4e4e7">`forcats::as_factor()`</span>. These functions converts each distinct category to some number placeholder in the background.

Let's get a better feel for the non-numeric data in the datasets we will be considering here.

### brewing_materials

Let's have a look at the `material_type` and `type` fields in the <span style="color: #5196b4;background-color:#f4e4e7">brewing_materials</span> dataset.

```{r}
brewing_materials %>% 
  count(material_type)

brewing_materials %>% 
  count(type)

brewing_materials %>% 
  filter(stringr::str_to_lower(material_type) %in% 
           c('grain products',
             'non-grain products')) %>% 
  count(material_type, type)
```

### factor() / as.factor()

1. These are conversion functions to convert a variable to a factor in Base R.

1. To convert a variable to a factor we may use: 

    a. `df <- df %>% mutate(var = factor(var))`
    a. `df <- df %>% mutate(var = as.factor(var))`
       
1. To figure out what number placeholder a category was given behind the scenes, use <span style="color: #5196b4;background-color:#f4e4e7">`levels()`</span>.

1. The default order of `factor()` is sorted. According to the help page: "The levels of a factor are by default sorted, but the sort order may well depend on the locale at the time of creation, and should not be assumed to be [ASCII](https://theasciicode.com.ar/)."


    ```{r}
    brewing_materials %>% 
      mutate(material_type = factor(material_type)) %>% 
      # use dplyr::pull which acts like $ to get the variable
      pull(material_type) %>% 
      # let us get the number placeholder attached to each category
      levels()
    
    brewing_materials %>% 
      mutate(material_type = as.factor(material_type)) %>% 
      # can also use count() to count how many in each level
      count(material_type)
    ```
    
    Notice that the base R functions `factor()` / `as.factor()`
    created `levels` in the alphabetical sorted order (my locale is ASCII). The output of the first part of the code block shows that `"Grain Products"` was coded as __1__, while `"Total Non-Grain products"` was coded as __4__, and `"Total Used"` was coded as the last level which was __5__.


1. What if I wanted to __specify the levels__ myself? I could specify the __levels__ in an argument as shown: <span style="color: #5196b4;background-color:#f4e4e7">`levels = c("Level1", ..., "LevelN")`</span>.

    ```{r}
    brewing_materials %>% 
      mutate(material_type = factor(material_type,
                    # I want to make a factor but I want the order to be
                    # as follows:
                    levels = c("Grain Products",
                               "Total Grain products",
                               "Non-Grain Products",
                               "Total Non-Grain products",
                               "Total Used"))) %>% 
      pull(material_type) %>% 
      levels()
    ```
    
    My level specification is used to create the levels, so the numeric encoding follows my specification this time. `"Total Grain products"` is coded as level __2__ this time (it was level 3 in the default creation where no `levels` argument was specified).

1. What if I wanted to include levels that may exist in future datasets, but don't as yet in the dataset we have? This is similar to the `months` example in [R for Data Science](https://r4ds.had.co.nz/factors.html). 
Let's try it with adding a _Not Applicable_ level, which is not in our dataset's `material_type` variable.

    ```{r}
    brewing_materials %>% 
      mutate(material_type = factor(material_type,
                              levels = c("Grain Products",
                                         "Total Grain products",
                                         "Non-Grain Products",
                                         "Total Non-Grain products",
                                         "Total Used",
                                         "Not Applicable"))) %>% 
      pull(material_type) %>% 
      levels()
    ```
    
    Has it been created?
    
    ```{r}
    brewing_materials %>% 
      mutate(material_type = factor(material_type,
                              levels = c("Grain Products",
                                         "Total Grain products",
                                         "Non-Grain Products",
                                         "Total Non-Grain products",
                                         "Total Used",
                                         "Not Applicable"))) %>%
      # we can also count as before but notice that
      # one category that has no data is missing -
      # the artificial `Not Applicable` we added
      count(material_type)
    
    ```
    
    A simple `count()` does not quite let us know, but if we add 
    an argument `.drop = FALSE` we get counts for all categories, even those
    with no observations (i.e. that category has a count of 0). By default the `count()` function drops categories with 0 counts from the output. By adding `.drop = FALSE` we're asking for these to be included.
    
    ```{r}
    brewing_materials %>% 
      mutate(material_type = factor(material_type,
                              levels = c("Grain Products",
                                         "Total Grain products",
                                         "Non-Grain Products",
                                         "Total Non-Grain products",
                                         "Total Used",
                                         "Not Applicable"))) %>%
      # we can get all categories by adding the .drop = FALSE
      count(material_type, .drop = FALSE)
    ```


<aside>
My locale is English South African, and hence is ASCII. The order preference in sorting is: [..., !, ", #, ..., 0, 1, ..., 9, ..., A, ..., Z, ...].
</aside>


### forcats::as_factor()

<span style="color: #5196b4;background-color:#f4e4e7">`as_factor()`</span> behaves differently to `as.factor()` in that it creates levels in the order in which they appear, hence we get the same factor levels across different locales. 

<aside>
Note the underscore <span style="color: #5196b4;background-color:#f4e4e7">`_`</span> instead of the __`.`__: as<b>_</b>factor
</aside>

#### Base R's as.factor()

```{r}
test_factor_var <-  c("012star", "DogsRule", "!this", "%abc",
            "Abc#", "abc$", "$bb", "AreYouKiddingCatsRule!")

test_factor_var %>% 
  as.factor() %>% 
  print(width = Inf)
```

Note that the levels (seen in the output <span style="color: #5196b4;background-color:#f4e4e7">`Levels: !this $bb ...`</span>) follow the [ASCII] sort on my machine, this may be completely different based on your locale.

#### Contrast with forcats::as_factor()

Now let's consider `as_factor()`. 

```{r}
# here is the raw variable again
test_factor_var

# Now let's make it a factor, this time using
# as_factor()
test_factor_var %>% 
  as_factor() %>% 
  print(width = Inf)
```

Note that `as_factor()` kept the order as it appears (<span style="color: #5196b4;background-color:#f4e4e7">`Levels: 012star DogsRule ...`</span>), this will be the same for you, even if your locale is different.

#### Convert brewer data

Let's perform the same conversion we did with Base R functions, but now using <span style="color: #5196b4;background-color:#f4e4e7">`forcats::as_factor()`</span>.

- First let's have a look at the default order that `as_factor()` creates the variable in.
    
    ```{r}
    brewing_materials %>% 
      pull(material_type) %>% 
      # what order are material_type observations in?
      head(12)
    
    brewing_materials %>% 
      mutate(material_type = as_factor(material_type)) %>% 
      pull(material_type) %>% 
      levels()
    ```
    
    Notice the levels are created in the order they appear in the
    `material_type` field - `"Grain Products"` appeared first hence is Level __1__, `"Total Grain products"` appeared second hence occupies Level __2__.

### fct_inorder()

We can also explicitly use the <span style="color: #5196b4;background-color:#f4e4e7">`fct_inorder()`</span> function to reorder the factor levels by first appearance. I add it here just so you're aware of this option.

For example, the `beer_awards$medal` column would be made alphabetical in my locale if I use as.factor(). 

```{r}
beer_awards %>% 
  head(3)

beer_awards %>% 
  mutate(medal = as.factor(medal)) %>% 
  pull(medal) %>% 
  levels()
```

Notice the alphabetical ordering of levels (Bronze, Gold, Silver).

If I follow this with a `fct_inorder()` the ordering of levels is now using the order of appearance instead.

```{r}
beer_awards %>% 
  mutate(medal = as.factor(medal) %>% fct_inorder()) %>% 
  pull(medal) %>% 
  levels()
```

In most cases we'd want this to be Bronze, Silver, Gold in order of increasing award type. We'll see how to do that just now.


## Manually order levels

### fct_relevel()

- Now we may specify the order ourselves (i.e. manually order the levels) by using <span style="color: #5196b4;background-color:#f4e4e7">`fct_relevel()`</span>. For example, as we talked about previously, we may want the award medals to be ordered Bronze, Silver, Gold in order of increasing award type, instead of order of appearance (or Base R's alpha sorting in my locale).
    
    ```{r}
    beer_awards %>% 
      # I want to specify my factor levels myself
      mutate(medal = fct_relevel(medal,
                     # we want a specific order, and
                     # the order in which the categories
                     # appear does not meet that specification
                                 "Bronze",
                                 "Silver",
                                 "Gold")) %>% 
      pull(medal) %>% 
      levels()
    ```

- We can't add a level that is not in the dataset, or we can, but we get a <span style="color: #FFE4E1;background-color:#FD5800">Warning</span>), and the level is not added.


    ```{r, warning = TRUE}
    brewing_materials_forcats <- brewing_materials %>% 
      # create a factor
      mutate(material_type = as_factor(material_type))
    
    brewing_materials_forcats %>%
      pull(material_type) %>% 
      # what's the default levels?
      levels()
    
    brewing_materials_forcats %>% 
      # we relevel by specifying the order we want
      mutate(material_type = fct_relevel(material_type,
                                         "Grain Products",
                                         "Non-Grain Products",
                                         "Total Grain products",
                                         "Total Non-Grain products",
                                         "Total Used",
                                         # adding a level that does not exist
                                         "Not Applicable")) %>% 
      pull(material_type) %>% 
      levels()
    ```
    
    Notice the warning you get (<span style="color: #FFE4E1;background-color:#FD5800">Warning: Problem with mutate ... </span>. We can't specify a "level" that does not
    exist in the observations.
    
    You may have a factor variable that at present has only some of the categories. For example, you may have a month factor variable where the dataset you're working with
    only has observations for some months at present. In this
    case you are going to be specifying the levels yourself so the best is to
    use the base functions, and specify all months in your `levels` argument
    despite these not being a part of the values seen in the observations at
    present.

- The nice part about `fct_relevel()` is you don't have to list all the categories, sometimes you just want to move one level to the beginning, you may do this as shown below. You may also move some part of the list to a specific position, which may be done using the <span style="color: #5196b4;background-color:#f4e4e7">`after`</span> argument.

    * Say I want to move all the "Total" columns up front:

        ```{r}
        # Levels at present are:
        brewing_materials_forcats %>%
          pull(material_type) %>% 
          levels()
        
        brewing_materials_forcats %>% 
          # move Total columns to the front of levels
          mutate(material_type = fct_relevel(material_type,
                                             "Total Used",
                                             "Total Grain products",
                                             "Total Non-Grain products")) %>% 
          pull(material_type) %>% 
          levels()
        ```
        
        Notice I did not list all categories. The remaining levels will fall
        behind the "Total" columns in the order they were originally.
    
    * Say I want to move "Grain Products" to the end. I can specify `after = Inf` to do this.

        ```{r}
        # Levels at present are:
        brewing_materials_forcats %>%
          pull(material_type) %>% 
          levels()
        
        brewing_materials_forcats %>% 
          # move "Grain Products" to the end of the levels
          mutate(material_type = fct_relevel(material_type,
                                             "Grain Products", 
                                             after = Inf)) %>% 
          pull(material_type) %>% 
          levels()
        ```
        
    * Say I want to move the "Total Grain products" and "Total Non-Grain products" to after the individual amounts. I again can use the `after` argument to do this. It is easy to get confused as to what integer your `after` should be set as. I think of it as "What position would I like my moved levels to start from"? In this case I want it to start by occupying slot number 3, then slot number 4, so I set `after = 2`, meaning "Please put these moved levels after slot number 2".

        ```{r}
        # Levels at present are:
        brewing_materials_forcats %>%
          pull(material_type) %>% 
          levels()
        
        brewing_materials_forcats %>% 
          mutate(material_type = fct_relevel(material_type,
                                             c("Total Grain products",
                                               "Total Non-Grain products"), 
                                             # what slot in the levels
                                             # should these go into?
                                             # I want them to start in slot 3
                                             # so I set  after = 2
                                             after = 2)) %>% 
          pull(material_type) %>% 
          levels()
        ```    
    

## Collapse multiple levels

### brewer_size
Let's have a look at the `brewer_size` field in the <span style="color: #5196b4;background-color:#f4e4e7">`brewer_size`</span> dataset.

```{r}
brewer_size %>% 
  count(brewer_size)

brewer_size %>% 
  count(brewer_size, 
        # count's default is to consider the number of rows
        # in each group, we can change it using wt (weight)
        # weight in this example is:
        # the number of brewers in each brewer size category, 
        # so count will sum up `n_of_brewers` for each category of brewer_size
        wt = n_of_brewers)
```

Notice that the brewer_size variable has a few categories which are slightly different, but which overlap.

|  brewer_size                     | 
|:--------------------------------:|
|  1,000,000 to 6,000,000 Barrels  |
|  1,000,001 to 6,000,000 Barrels  |
|  1,000,001 to 1,999,999 Barrels  |
|  2,000,000 to 6,000,000 Barrels  |

If you look closely it seems as though _1,000,000 to 6,000,000 Barrels_ may be a typo, since _500,001 to 1,000,000 Barrels_ is already a category in that year.

It also looks as if _1,000,001 to 6,000,000 Barrels_ was split into _1,000,001 to 1,999,999 Barrels_ and _2,000,000 to 6,000,000 Barrels_ from 2011 onwards.

### fct_collapse()

We can consolidate these levels into one level by using `fct_collapse()`.

```{r}
# what are the current levels in this variable
brewer_size %>% 
  mutate(brewer_size = as_factor(brewer_size)) %>% 
  pull(brewer_size) %>% 
  levels()

brewer_size %>% 
  mutate(brewer_size = as_factor(brewer_size)) %>% 
  mutate(brewer_size = fct_collapse(brewer_size,
            # the new category name
            "1,000,000 to 6,000,000 Barrels" = 
            # the current categories that must become
            # the new category
              c("1,000,000 to 6,000,000 Barrels",
                "1,000,001 to 6,000,000 Barrels",
                "1,000,001 to 1,999,999 Barrels",
                "2,000,000 to 6,000,000 Barrels")
        )) %>% 
  pull(brewer_size) %>% 
  levels()
```

Notice that our previous __16__ levels are now __13__.

In this case we'd also want to reorder the levels further by using `fct_relevel()`.

```{r}
brewer_size %>% 
  mutate(brewer_size = as_factor(brewer_size)) %>% 
  mutate(brewer_size = fct_collapse(brewer_size,
            "1,000,000 to 6,000,000 Barrels" = 
              c("1,000,000 to 6,000,000 Barrels",
                "1,000,001 to 6,000,000 Barrels",
                "1,000,001 to 1,999,999 Barrels",
                "2,000,000 to 6,000,000 Barrels")
        )) %>% 
  mutate(brewer_size = fct_relevel(brewer_size,
        "Zero Barrels",
        "Under 1 Barrel",
        "1 to 1,000 Barrels",
        "1,001 to 7,500 Barrels",
        "7,501 to 15,000 Barrels",
        "15,001 to 30,000 Barrels",
        "30,001 to 60,000 Barrels",
        "60,001 to 100,000 Barrels",
        "100,001 to 500,000 Barrels",
        "500,001 to 1,000,000 Barrels",
        "1,000,000 to 6,000,000 Barrels",
        "6,000,001 Barrels and Over")) %>% 
  pull(brewer_size) %>% 
  levels()
```


## Reduce categories

We saw that `fct_collapse()` is used to reduce categories. In the above example, there was some order to the levels so the best we can do is collapse levels into fewer categories, i.e. an `Other` category does not make much sense in the example we used above.

Some times you have way too many levels to visualise, or be useful in considerations, but there isn't any inherent order in the levels. We will discuss different category reduction strategies for these (i.e. where an `Other` category is a viable option).

### beer_awards

Let's use the `beer_awards` dataset for this part.

```{r}
beer_awards %>% 
  count(brewery, sort = TRUE) %>% 
  DT::datatable()

beer_awards %>% 
  count(category, sort = TRUE) %>% 
  DT::datatable()

beer_awards %>% 
  count(city, sort = TRUE) %>% 
  DT::datatable()
```

### fct_other()

We can also collapse levels by grouping together some levels into `Other` using <span style="color: #5196b4;background-color:#f4e4e7">`fct_other()`</span>. 

In `fct_other()` we can either:

    - specify which categories we want to __keep__, where all the rest will be bucketed into the `Other` category.
    - specify which categories we want to __drop__ - i.e. which categories do we want to be bucketed into the `Other` category.
<br> <br>

1. Let's say that we're only interested in the _Pilseners_ in the `category` variable.

    We can __keep__ these Pilseners, and combine all others into a __Non-Pilseners__ category using `fct_other()` with the <span style="color: #5196b4;background-color:#f4e4e7">`keep`</span> argument.

    ```{r}
    beer_awards %>% 
      mutate(category = as_factor(category)) %>% 
      mutate(category = fct_other(category,
                # which levels do you want to keep?
                keep = c('German-Style Pilsener',
                'Bohemian Style Pilsener',
                'Bohemian-Style Pilsener',
                'European-Style Pilsener',
                'American-Style or International-Style Pilsener',
                'International-Style Pilsener',
                'European Pilsner',
                'European Style Pilsener',
                'American Light Pilsners',
                'American-Style Lager or American-Style Pilsener',
                'American-Style Pilsener',
                'American-Style Pilsener or International-Style Pilsener',
                'American Pilsener',
                'American Pilseners',
                'American Pilsners',
                'American Premium Dark Pilseners',
                'Continental Pilsners',
                'European Classic Pilseners',
                'German Style Pilsener',
                'International Pilsener',
                'Mixed, European Pilsener',
                'American Premium Dark Pilsners',
                'American Premium Pilseners',
                'American Premium Pilsners',
                'Contemporary American-Style Pilsener',
                'Pilsener'),
                # relabel the 'Other' level
                other_level = "Non-Pilseners"
            )) %>% 
      pull(category) %>% 
      levels()
    
    ```
    
    We have successfully kept all Pilseners, and all others have been grouped into the "Non-Pilseners" category.

1. What if we want to keep everything else, and group all Pilseners into a separate category? We can instead use the <span style="color: #5196b4;background-color:#f4e4e7">`drop`</span>  argument.
    
    ```{r}
        beer_awards %>% 
          mutate(category = as_factor(category)) %>% 
          mutate(category = fct_other(category,
                    # which levels do you want to drop?
                    drop = c('German-Style Pilsener',
                    'Bohemian Style Pilsener',
                    'Bohemian-Style Pilsener',
                    'European-Style Pilsener',
                    'American-Style or International-Style Pilsener',
                    'International-Style Pilsener',
                    'European Pilsner',
                    'European Style Pilsener',
                    'American Light Pilsners',
                    'American-Style Lager or American-Style Pilsener',
                    'American-Style Pilsener',
                    'American-Style Pilsener or International-Style Pilsener',
                    'American Pilsener',
                    'American Pilseners',
                    'American Pilsners',
                    'American Premium Dark Pilseners',
                    'Continental Pilsners',
                    'European Classic Pilseners',
                    'German Style Pilsener',
                    'International Pilsener',
                    'Mixed, European Pilsener',
                    'American Premium Dark Pilsners',
                    'American Premium Pilseners',
                    'American Premium Pilsners',
                    'Contemporary American-Style Pilsener',
                    'Pilsener'),
                    # relabel the 'Other' level
                    other_level = "Pilseners"
                )) %>% 
          pull(category) %>% 
          levels() %>% 
          as_tibble() %>% 
          DT::datatable()
    ```
    
    There are no individual "Pilsener" observations now, instead all Pilseners have been grouped into the "Other" category which we renamed to be "Pilseners".
    

### fct_lump()

In the `beer_awards$city` variable we have `r beer_awards %>% distinct(city) %>% summarise(n=n()) %>% pull(n)` cities. Say we're only interested in the top 10 cities represented in the awards. 

- We can do this using <span style="color: #5196b4;background-color:#f4e4e7">`fct_lump()`</span> along with the argument <span style="color: #5196b4;background-color:#f4e4e7">`n`</span>.

    ```{r}
    beer_awards %>% 
      mutate(city = as_factor(city)) %>% 
      # keep the top 10 cities with the most observations
      # and collapse all other cities into an `Other` category
      mutate(city = fct_lump(city, n = 10)) %>% 
      pull(city) %>% 
      levels()
    ```

- We can also keep categories with some percentage of the observations using `fct_lump()` along with the argument <span style="color: #5196b4;background-color:#f4e4e7">`prop`</span>.

    ```{r}
    beer_awards %>% 
      mutate(city = as_factor(city)) %>% 
      # keep the cities with at least 1.5% of the observations
      # and collapse all other cities into an `Other` category
      mutate(city = fct_lump(city, prop = 0.015,
                             # we can again relabel the 'Other' category
                             other_level = "Rest of the Cities")) %>% 
      pull(city) %>% 
      levels()
    ```

## Re-labeling levels

Sometimes your factor categories will have long names. You many want to shorten these for graphs etc.

### brewing_materials$type 

```{r}
brewing_materials %>% 
  count(type, sort = TRUE)
```

### fct_recode()

The `brewing_materials$type` variable has some long names. Let's use <span style="color: #5196b4;background-color:#f4e4e7">`fct_recode()`</span> to rename these.

```{r}
brewing_materials %>% 
  mutate(type = as_factor(type)) %>% 
  mutate(type = fct_recode(type,
          # "new_name" = "old_name"                 
          "Barley"     = "Barley and barley products",
          "Malt"       = "Malt and malt products",
          "Rice"       = "Rice and rice products",
          "Corn"       = "Corn and corn products",
          "Wheat"      = "Wheat and wheat products",
          # Notice here I am kinda doing the equivalent of fct_collapse()
          # by assigning 2 categories to new "Hops" category
          "Hops"       = "Hops (dry)",
          "Hops"       = "Hops (used as extracts)"
          )) %>% 
  count(type, sort = TRUE)
```


## Reorder levels

When visualising data we often want to reorder the levels of our factors. We can use <span style="color: #5196b4;background-color:#f4e4e7">`fct_reorder()`</span>, <span style="color: #5196b4;background-color:#f4e4e7">`fct_reorder2()`</span>, <span style="color: #5196b4;background-color:#f4e4e7">`fct_infreq()`</span> and <span style="color: #5196b4;background-color:#f4e4e7">`fct_rev()`</span> for ordering our factors for visuals.

### fct_infreq() and fct_rev()

<span style="color: #5196b4;background-color:#f4e4e7">`fct_infreq()`</span> orders by the frequency of each category.

Let's say we were interested in which breweries did the best over time in terms of winning gold medals.

```{r, layout="l-body-outset", out.width = '70%', out.height = '70%'}
theme_set(theme_light())

beer_awards %>% 
  # I only care about Gold medals
  filter(medal == "Gold") %>% 
  # I am only interested in top 10 most successful breweries
  mutate(brewery = fct_lump(brewery, n = 10,
                            # if there are ties in 10th and 11th position, keep the first one
                            ties.method = "first")) %>% 
  # add a count variable which will be named `n`
  add_count(brewery, medal) %>% 
  # remove the Other category since it overwhelms the plot
  filter(brewery != "Other") %>% 
  # order the brewery by the frequency in each brewery
  ggplot(aes(y = fct_infreq(brewery))) +
  geom_bar(fill = "#f4e4e7") +
  geom_text(aes(label = as.character(n),
                x = n + .06), hjust = "center",
            colour = "#5196b4") +
  labs(x = "",
       y = "",
       title = "Breweries that won the most gold medals over time") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

The `fct_infreq()` orders it from most frequent (which is shown at bottom of plot, because ggplot plots the levels from the bottom going up) to least frequent (shown at top of plot). Visually we see the least frequent at top of the plot, and most frequent at the bottom of the plot.

To see what `fct_infreq()` does let's look at the levels.

```{r, layout="l-body-outset"}
beer_awards %>% 
  filter(medal == "Gold") %>% 
  mutate(brewery = fct_lump(brewery, n = 10,
                            ties.method = "first")) %>%
  filter(brewery != "Other") %>%
  mutate(brewery = fct_infreq(brewery)) %>% 
  pull(brewery) %>% 
  levels()
```

It is sometimes better to see bar plots in descending order on the visual (i.e. we want to see the most frequent at top of plot, and least frequent at the bottom). This can be accomplished by combining <span style="color: #5196b4;background-color:#f4e4e7">`fct_rev()`</span> with <span style="color: #5196b4;background-color:#f4e4e7">`fct_infreq()`</span>.

```{r, layout="l-body-outset"}
beer_awards %>% 
  filter(medal == "Gold") %>% 
  mutate(brewery = fct_lump(brewery, n = 10,
                            ties.method = "first")) %>% 
  add_count(brewery, medal) %>% 
  filter(brewery != "Other") %>%
  # show in decreasing order of winners on plot
  ggplot(aes(y = fct_rev(fct_infreq(brewery)))) +
  geom_bar(fill = "#f4e4e7") +
  geom_text(aes(label = as.character(n),
                x = n + .06), hjust = 1.2,
            colour = "#5196b4",
            size = 4.5,
            position = position_dodge(width = 1)) +
  labs(x = "",
       y = "",
       title = "Breweries that won the most gold medals over time") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

```{r, layout="l-body-outset"}
beer_awards %>% 
  mutate(brewery = fct_lump(brewery, n = 10)) %>% 
  add_count(brewery, medal) %>% 
  filter(brewery != "Other") %>% 
  ggplot(aes(y = fct_rev(fct_infreq(brewery)))) +
  geom_bar(fill = "#f4e4e7") +
  geom_text(aes(label = as.character(n),
                x = n + .06), hjust = 1.2,
            colour = "#5196b4",
            size = 4.2,
            position = position_dodge(width = 1)) +
  facet_wrap(~ fct_inorder(medal)) +
  labs(x = "",
       y = "",
       title = "Most successful breweries over time",
       subtitle = "In all medal categories") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

### fct_reorder()

On occasion you may want to reorder to make your visuals easier to read. You can do this using <span style="color: #5196b4;background-color:#f4e4e7">`fct_reorder()`</span>.

<span style="color: #5196b4;background-color:#f4e4e7">`fct_reorder(var, some_other_var, some_func)`</span> where:

- var: the variable you want to reorder (below this is the `brewery` variable)
- some_other_var: what should determine the order that var will be put into? Below we're going to reorder `brewery` by the count of medals the brewery received.
- some_func: Is there some summary function that must be applied? For example, should we sum up some_other_var, or take the median of some_other_var for the order of var to be determined by. Below since we have Bronze, Silver and Gold medals we're going to sum up the counts in each medal category and use that to determine which order `brewery` should be in.

Ultimately we want to plot the most successful breweries from most successful to least successful in the top 10.

```{r}
beer_awards %>% 
  # keep top 10 breweries, lump all the rest into Other
  mutate(brewery = fct_lump(brewery, n = 10)) %>% 
  add_count(brewery, medal) %>% 
  select(brewery, medal, n) %>% 
  distinct() %>% 
  # remove the "Other" category because it makes it hard
  # to see all the rest
  filter(brewery != "Other") %>% 
  # reorder the brewery by the sum of the number of all
  # medals such that brewery with most medals are at top
  mutate(brewery = fct_reorder(brewery, n, sum)) %>% 
  mutate(medal = fct_relevel(medal,
                                "Bronze",
                                "Silver",
                                "Gold")) %>% 
  ggplot(aes(n, brewery, 
             fill = medal)) +
  geom_col() +
  geom_text(aes(label = n, fontface = "bold"), 
            position = position_stack(vjust = 0.5),
            colour = "white") +
  scale_fill_viridis_d() +
  labs(x = "",
       y = "",
       title = "Breweries with the most medals",
       fill = "Medal") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE))
  
```

## Code

You will find the RMarkdown replica of this post [here](https://github.com/sciencificity/forcats-tutorial/blob/master/forcats_tutorial.Rmd).

## Session Info

```{r, code_folding = TRUE}
sessionInfo()
```


# Further Resources

1. Chapter on [Factors](https://r4ds.had.co.nz/factors.html) in `R for Data Science`.
1. {forcats} [Tidyverse Page](https://forcats.tidyverse.org/).
1. [Vignette on {forcats}](https://forcats.tidyverse.org/articles/forcats.html) by [Emily Robinson](https://twitter.com/robinson_es?lang=en).
1. [David Robinson's TidyTuesday screencasts](https://www.youtube.com/channel/UCeiiqmVK07qhY-wvg3IZiZQ) often include much factor wrangling.

